1、如何将长url变为短url
短网址服务提供平台:http://sina.lt/
一定要保证长期可靠的服务，不然一段时间失效了，我们以前已经转换的URL就完了！
所以 自己造轮子！！！！！！

通过发号器，给每一个过来的长地址发一个号
小型系统直接用mysql自增索引搞定，大型系统可以考虑用key-value系统做发号器
http://t.cn/RuPKzRW 短链接服务器t.cn，短链接号RuPKzRW（62进制）
问题:
	1)62进制如何用数据库或者KV存储
	  储存时用10进制存储，等到要使用时转换成62进制即可
	2)如何保证长地址每次转出来都是一样的短地址
	  建立一个长对短的hashtable，相当于用空间换取空间，同时换取一个设计上的优雅
	  还有一种，用key-value存储，使用LRU淘汰方式，在最近表中查看长地址有没有对应的短地址，有就直接返回，并将失效时间增长1小时；没有就通过发号器生成一个短地址，保存到最近表中，过期时间为1小时。（KV中如何快速取到value）
	3)如何保证发号器的大并发高可用
	  如果将发号器做成分布式，那么多节点要保持同步加1，多点同时写入，按照CAP理论看，是不可能实现的
	  退一步考虑，是否可以实现两个发号器，一个发单号，一个发双号，这样单点就变成多点了。
	  依次类推，可以实现1000个逻辑发号器，分别发尾号为0~999的号，每发一个号，每个发号器加1000，不是加1
	  这些发号器独立工作，互不干扰
	  将长链接与短链接映射关系的存储进行分片，由于没有一个中心化的存储位置，因此需要开发额外的服务，用于查找短链接对应的原始链接的存储节点，这样才能去正确的节点上找到映射关系。
	4)具体存储如何选择
	  对市面上DB、cache系统可用性、并发能力、一致性等存储服务器的理解
	5)跳转用301还是302
	  浏览器缓存机制。301是永久重定向，302是临时重定向
	  短地址一经生成就不再变化，所以用301是符合http定义，同时对服务器压力也会减小。但是如果使用了301，我们就无法统计到短地址被点击的次数了，
	  而这个点击次数是一个非常有意思的大数据分析数据源，使用这个点击次数能分析出非常非常多东西，所以选择302会增加服务器压力，但我想会是个更好的选择。
	  
生成短地址之后如何跳转哪？
对于该部分的讨论，我们可以认为他是整个交互的流程，具体的流程细节如下：
（1）用户访问短链接：http://t.cn/RuPKzRW；
（2）短链接服务器t.cn收到请求，根据URL路径RuPKzRW获取到原始的长链接（KV缓存数据库中去查找）：https://blog.csdn.net/xlgen157387/article/details/79863301；
（3）服务器返回302状态码，将响应头中的Location设置为：https://blog.csdn.net/xlgen157387/article/details/79863301；
（4）浏览器重新向https://blog.csdn.net/xlgen157387/article/details/79863301发送请求；
（5）返回响应；



注意：urlshorter本身还是基于随机的方式生成短地址的，并不算是一个短地址发号器，因此会有性能问题和冲突的出现
项目地址：https://gitee.com/tinyframework/urlshorter

id生成器地址：https://gitee.com/xuliugen/codes/9upvmzyk6c2i78eb3lgnj63
vesta
码云：https://gitee.com/robertleepeak/vesta-id-generator 
GitHub：https://github.com/cloudatee/vesta-id-generator


一致性hash

可重入锁