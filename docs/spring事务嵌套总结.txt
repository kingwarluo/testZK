spring事务总结嵌套

1、同一个类中事务方法互相调用，不会被事务管理
	原因：事务原理是springAOP机制，在同一个类方法A调用方法B，方法B不会被事务管理
	解决方法：
	1、可将方法放入另一个类，并且该类通过spring注入，即符合了在对象之间调用的条件
	2、获取本对象的代理对象，再进行调用，具体操作：
		1）spring-context.xml上下文中，增加配置：<aop:aspectj-autoproxy expose-proxy="true"/>
		2）再XXXServiceImpl中，用(AopContext.currentProxy())，获取到XXXService的代理类，再调用事务方法，强行经过代理类，激活事务切面
	3、把注解加到类名上面；（不推荐）

2、嵌套事务

	例如有如下场景：
	BEGIN TRAN
		循环100张订单
		BEGIN
			BEGIN TRAN --1张订单作为一个子事务
			...
			ROLLBACK TRAN --订单有自己的明细，如果某个明细有错，只回滚这个订单
			COMMIT TRAN   --全部明细处理成功，则递交这个订单
		END
	   
		对处理成功的订单汇总，比如进行汇总支付
	 
	ROLLBACK TRAN --如果支付不成功，所有订单必须回滚
	COMMIT TRAN   --如果支付成功，整体递交

	对每张订单，内部出现错误，只回滚当前订单，并不会回滚外部事务。
	所以外部（A）事务用默认的required，内部嵌套（B）事务用required_new
	这种情况，内部（B）事务发生回滚时，在内部try_catch将异常处理，这样只有B事务会发生回滚，A事务正常提交

3、如下场景
	两个事务都是required，且A事务方法调用B事务方法
	此时如果B事务方法发生异常，A事务捕获回滚时，会报一个异常，Transaction rollback-only
	因为不会开启一个新事务
	
	解决方法：1、将B事务方法传播方式改为required_new
			  2、（在场景允许的情况下）将B事务方法取消事务
			  我采用第二种
			  
事务隔离级别：
脏读：事务A插入数据1，忘记提交事务；事务B查询数据1，结果能查询到，数据1就是脏读；
不可重复读:事务A查询数据1，此时事务B修改数据1，事务A再次读取数据1，此时数据1不可重复读；
幻读：事务A按条件查询，查出3条数据；此时事务B插入一条数据，事务A再次查询，查询出4条数据，幻读；

读未提交（Read Uncommitted）：不能阻止脏读、不可重复读、幻读。
读提交（Read Committed）：使用“快照读”锁住被读取记录，能阻止脏读；不能阻止不可重复读、幻读。
可重复读（Repeated Read）：使用“快照读”锁住被读取记录，能阻止脏读、不可重复读；不能阻止幻读。
串行化（Serializable）：排排坐，吃果果，能有效避免脏读、不可重复读、幻读，但是效率非常低下，基本没人用。