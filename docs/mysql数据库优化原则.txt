1、当表数据量大时，分页查询可以先查出前面n页的最大id，带入查询语句，加上条件 where id>n limit 0, 10

2、操作优先级是from>where>group by>having>order by，left join 属于from操作，left join 后的数据会创建一张临时表，where在临时表上对数据进行筛选

3、关于group by耗时，尽量不要group by整张表

4、关于order by 耗时，可以先减少order by的数据量

5、使用force index强制使用某个索引，使用ignore index忽略某个索引

6、查询条件使用了多个索引，索引会选取哪个？

7、left join后，为什么会使用原表索引？-- 本来就会用到

7.1 查询未走索引原因
  -- 字符集不一样
  -- order by导致

8、简单的 select * from A left join B on A.c = B.c where A.employee_id = 3，这是有问题的。
	https://www.jianshu.com/p/a0673621c94f
	b表索引c，a表索引 employee_id + c为最佳性能。
		这一句Sql在执行的时候首先是选择了使用表B的索引来进行优化，
		将表A单独放出来进行后续的操作，
		然后，又发现了where语句中A.employee_id有一个聚合索引，
		并且employee_id处于索引头，所以这个聚合索引是可用的，
		so自然使用了此索引
		
9、读写分离导致的问题。在留咨系统中，我写了一个批量异步创建主线索的流程，本身代码控制上没问题。但是这线程里有一个操作，
	在同一个事务里，创建完主线索，马上要将主线索读取出来。这时候如果有做新增表字段或什么操作，看到从数据库延迟主数据库50s（可能是新增字段修改的数据量较大，导致时间长，因为修改字段的表都是百万级别），
	这时候事务内普通查询，走写库。根据id查询，走读库。因为读库数据同步延迟，所以导致查询失败。

充分利用但不滥用索引，须知索引也消耗磁盘和CPU。

不推荐使用数据库函数格式化数据，交给应用程序处理。

不推荐使用外键约束，用应用程序保证数据准确性。

写多读少的场景，不推荐使用唯一索引，用应用程序保证唯一性。

适当冗余字段，尝试创建中间表，用应用程序计算中间结果，用空间换时间。

不允许执行极度耗时的事务，配合应用程序拆分成更小的事务。

预估重要数据表（比如订单表）的负载和数据增长态势，提前优化。


mysql left join 原理
1、Simple Nested-Loop Join（简单嵌套循环连接，效率是A*B条数次）
2、Index Nested-Loop Join（索引嵌套循环连接，非驱动表利用索引查找，效率更高）
3、Block Nested-Loop Join（效率与第一种一样，这种方式取出select和on的列）
原理：先将join的多个表按on条件拼接成一张临时表，再用where条件过滤
注意:开发时遵循小表驱动大表原则

mysql or查询执行过程及优化
注意：or里只要一个条件没索引，就不会走索引（原因：全表扫描+索引扫描+merge）、会引起sql注入（mybatis用#{}预编译sql避免）
原理：
优化：1、A=1 or (B=2 and c=3)，优化为select A=1 union select B=2 and c=3，用union查询然后排序
     2、单个（A=1 or A=2 or A=3）可以用in代替
     3、如果多条件(A=1 and B=2) or (A=2 and B=1)的，可以添加个唯一标识表示