1、当表数据量大时，分页查询可以先查出前面n页的最大id，带入查询语句，加上条件 where id>n limit 0, 10

2、操作优先级是from>where>group by>having>order by，left join 属于from操作，left join 后的数据会创建一张临时表，where在临时表上对数据进行筛选

3、关于group by耗时，尽量不要group by整张表

4、关于order by 耗时，可以先减少order by的数据量

5、使用force index强制使用某个索引

6、查询条件使用了多个索引，索引会选取哪个？

7、left join后，为什么会使用原表索引？

8、简单的 select * from A left join B on A.c = B.c where A.employee_id = 3，这是有问题的。
	https://www.jianshu.com/p/a0673621c94f
	b表索引c，a表索引 employee_id + c为最佳性能。
		这一句Sql在执行的时候首先是选择了使用表B的索引来进行优化，
		将表A单独放出来进行后续的操作，
		然后，又发现了where语句中A.employee_id有一个聚合索引，
		并且employee_id处于索引头，所以这个聚合索引是可用的，
		so自然使用了此索引
		
9、读写分离导致的问题。在留咨系统中，我写了一个批量异步创建主线索的流程，本身代码控制上没问题。但是这线程里有一个操作，
	在同一个事务里，创建完主线索，马上要将主线索读取出来。这时候如果有做新增表字段或什么操作，看到从数据库延迟主数据库50s（可能是新增字段修改的数据量较大，导致时间长，因为修改字段的表都是百万级别），
	这时候事务内普通查询，走写库。根据id查询，走读库。因为读库数据同步延迟，所以导致查询失败。

充分利用但不滥用索引，须知索引也消耗磁盘和CPU。

不推荐使用数据库函数格式化数据，交给应用程序处理。

不推荐使用外键约束，用应用程序保证数据准确性。

写多读少的场景，不推荐使用唯一索引，用应用程序保证唯一性。

适当冗余字段，尝试创建中间表，用应用程序计算中间结果，用空间换时间。

不允许执行极度耗时的事务，配合应用程序拆分成更小的事务。

预估重要数据表（比如订单表）的负载和数据增长态势，提前优化。