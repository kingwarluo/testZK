1、冷热分离
    背景：客服邮箱工单数据太多，查询缓慢，后经发现一部分数据很多场景大概率用不上
    - 如何区分冷热数据
        -- 按时间维度：一个月前的工单不查询
        -- 按状态维度：已完结状态的工单不再流转
        -- 时间+状态结合：一个月前的已完结工单不再使用
    - 什么时机触发冷热数据
        -- 更新工单数据时，同步更新冷热数据
            --- 好处：数据实时更新；代码灵活可控；
            --- 不足：需要修改所有写操作的代码；无法按照时间维度来区分冷热数据，当数据需要变为冷数据时，中间可能没有任何操作；
        -- 监听mysql的binlog日志，进行冷热数据更新
            --- 好处：与业务剥离，对不熟悉的复杂业务，使用这个方案；可以做到低延时；
            --- 不足：需要考虑并发操作问题，业务代码与冷热分离同时操作一条数据；无法按照时间维度来区分冷热数据，当数据需要变为冷数据时，中间可能没有任何操作；
        -- 启动一个定时任务，进行冷热数据更新
            --- 好处：与业务代码解耦；可覆盖基于时间区分冷热数据场景；
            --- 不足：不能做到实时性；
    - 如何实现数据冷热分离
        -- 步骤：1、查询出符合条件的冷热数据；2、将数据插入冷数据库；3、将数据从热数据库中删除
            --- 问题：数据最终一致性
                 1->2时失败，需要在热数据库加个字段needColdFlag=true，在中断时可重复处理；
                 2->3时失败，需做幂等性处理，将已插入冷数据库的热数据直接删除；
            --- 问题：一次处理不完
                循环处理：
                    - 查出1000条待处理数据；
                    - 插入冷数据库
                    - 从热数据库删除
            --- 问题：大批量迁移
                计算迁移数据量，根据数据量，启用多个定时任务或启动一个任务+多线程（这里启动10个任务）
                并发问题：多线程处理到同一条数据？
                    - 增加LockThread字段作为区分，开始处理前更新LockThread字段为当前线程id
                数据处理失败问题：某一线程退出，但是还是被LockThread锁住，导致永远不处理
                    - 增加LockTime字段，判断LockThread ！= null and LockTime + 10s < 当前时间，说明是处理失败的任务
                      这里的10s需要根据迁移测试后确定。
    - 如何使用冷热分离
        一般冷热数据不能有重合的使用场景；
    - 历史数据迁移
        同冷热数据分离；
    - 二期优化，将冷数据迁移至Hbase

2、查询分离
    背景：大数据量下，需要复杂的组合查询
    - 何为查询分离
        -- 每次写数据时，除了把数据写到主数据库外，另外保存一份到另外的存储系统里，用户查询直接从另外的存储系统获取数据
    - 何种场景下使用查询分离
        -- 数据量大
        -- 所有写数据请求效率尚可
        -- 查询数据的请求效率很低
        -- 所有数据任何时候都可能被修改
        -- 业务希望我们优化查询数据的功能

    - 如何触发查询分离
        -- 业务代码层实现
            - 写入常规数据后，同步建立查询数据；适用场景：业务代码比较简单且对写操作响应速度要求不高
                - 优点：业务逻辑灵活可控；保证查询数据的实时性和一致性；
                - 缺点：侵入业务代码；减缓写操作速度（影响很多，es索引、分片、主从备份）；
            - 写入常规数据后，异步建立查询数据；适用场景：业务代码比较简单并且对写操作响应速度有要求。（真实业务场景中，这种方式使用的比较多）
                - 优点：不影响主流程
                - 缺点：查询数据更新前，用户可能查询到过时的数据
        -- binlog实现
            - 有数据变更，则更新查询数据；适用场景：业务代码比较复杂，或改动代价太大
                - 优点：不影响主流程；业务代码0入侵
                - 缺点：查询数据更新前，用户可能查询到过时的数据；架构复杂一些
    - 如何实现查询分离
        -- 方式1：单独起一个线程建立查询数据
            - 写操作较多且线程太多，最终撑爆JVM
            - 建立查询数据线程出错，如何重试
            - 多线程并发时，并发场景解决
            不建议使用该方式
        -- 方式2：借用MQ进行管理
            - MQ选型？MQ宕机了怎么办？更新查询数据的线程失败了怎么办？消费的幂等性？消息的时序性问题？
                讨论后选型。增加NeedUpdateQueryData和LockThread（并发问题）标识。
                时序性（难理解）：每次写数据都更新last_update_time字段，每个线程更新完查询数据后，
                检查数据last_update_time是否和线程刚开始获得的时间一样，
                且NeedUpdateQueryData=false，都满足则更新NeedUpdateQueryData=true，再做一次搬运
                *（自己理解：就是利用last_update_time比较，保障查询数据更新的是最新数据）
    - 查询数据如何存储
        -- Elasticsearch
    - 查询数据如何使用
        -- 直接调用ES的API函数查询
    - 历史数据迁移
    - MQ + elasticsearch 整体方案

3、分库分表

4、缓存